### 第一章

嵌入式系统的组成：嵌入式处理器，外围设备，嵌入式操作系统，应用软件。

处理器工作模式：用户模式，快中断模式，中断模式，管理模式，数据访问终止模式，系统模式，未定义指令终止模式。

五种异常：中断模式，快中断模式，管理模式，数据访问终止模式，未定义指定终止模式。

二种：系统模式，用户模式。

ARM（Advanced RISC Machines），既可以认为是一个公司的名字，也可以认为是对一类微处理器的通称，还可以认为是一种技术的名字。**先进的精简指令集机器。**

嵌入式微处理器和嵌入式微控制器。

常见嵌入式处理器：51,32，s3c2410,晓龙，海思，MIPS,ARM,Power PC

常见嵌入式操作系统：VxWorks，WindowsCE，嵌入式Linux，UC/os-ii

交叉编译环境：在某个主机平台上(比如PC上)用[交叉编译器](https://baike.so.com/doc/7729609-8003704.html)编译出可在其他平台上(比如ARM上)运行的代码的过程。 

宿主机，目标机

### 第二章

ARM（Advanced RISC Machines），既可以认为是一个公司的名字，也可以认为是对一类微处理器的通称，还可以认为是一种技术的名字。

ARM寄存器：ARM微处理器共有37个**32位寄存器**，其中31个为通用寄存器，6个为状态寄存器。但是这些寄存器不能被同时访问，具体哪些寄存器是可以访问的，取决ARM处理器的工作状态及具体的运行模式。但在任何时候，通用寄存器  R14~R0、程序计数器PC、一个状态寄存器都是可访问的。 

寄存器R13通常做堆栈指针SP  。

寄存器R14用作子程序链接寄存器（Link Register-LR），也称为LR，指向函数的返回地址。 

寄存器R15被用作程序计数器，也称为PC。其值等于当前正在执行的指令的地址+8（因为在取地址和执行之间多了一个译码的阶段）。 

**当前程序状态寄存器**  CPSR。

特点：体积小，功耗低，低成本，高性能。ARM（32位）Thumb（16位）。

**RAM汇编指令：** 

```
DCD  分配空间并进行初始化。

MOV  R1, R2       ;R2->R1 

SUB  R0, R1,R2    ;R1-R2 -> R0 

SUBS R0,R0,#1      ;R0-1 -> R0 //带有S，影响CPSR寄存器。

MOV  R0,#0xff00    ;0xff00 -> R0 

MOV  R0,R2,LSL #3       ;R2的值左移3位，结果存入R0，即R0 = R2 * 8 

ANDS R1,R1,R2,LSL R3   ;R2的值左移R3位，然后和R1相与操作，结果放入R1

LDR R2,[R3,#0x0F]    ;将R3的数值加0x0F作为地址，取出此地址的数值保存在R2中

STR R1,[R0,#-2]      ;将R0中的数值减2作为地址，把R1中的内容保存到此地址位置

BNE  跳转指令

```



### S3c2410开发板

S3C2410 GPIO

内核电压  1.8  /2.0V   ，外设电压    3.3V ;

支持  5 个 16位 定时器，其中  4 个支持PWM;

支持  117  个GPIO接口，分为 8  组，其中全功能组为    组；

支持AMBA总线；

支持NAND FLASH启动

支持   56  个中断源；

支持两种中断：      和      

GPIO点亮LED灯：

GPACON----GPHCON  端口控制寄存器   通过设置GPACON寄存器将GPA设置的4个端口设置为输出状态。

GPA4（8,9），GPA5(10,11),   GPA6(12,13)....      **01output，00input 10toto 11reserved**

GPADAT-----GPHDAT  端口数据寄存器   配置为0低电平，配置为1高电平。

GPBUP---------GPHUP 端口上拉寄存器     0打开 1关闭



### 文件 IO编程

**open函数**

```c
int open(const char *pathname, int flags, mode_t mode);
```



​       **flag**

- O_RDONLY： 只读模式

- O_WRONLY：只写模式

- O_RDWR：   可读可写

- O_CREAT ： 创建文件

  **mode（0777）**

  ①文件所有者的权限，②用户组的权限，③其他用户的权限  读4写2执行1 

  

  **返回值**

  操作成功，返回我文件描述符。失败返回-1。

  

  **read函数**

  ```c
  ssize_t read(int fd, void *buf, size_t count);  
  ```

  将fd中的内容读取到buf中，读取count个字节

  **返回值**

  成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0。

  

  **write 函数** 

```c
ssize_t write(int fd, const void *buf, size_t count);  
```

   将buf中的数据写入fd中。

​     **返回值**

​     成功写入的字节数，0没有写入数据，-1出错。

​    **close函数**  关闭文件。



### 进程编程

